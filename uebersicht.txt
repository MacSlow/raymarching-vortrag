"Dreiecke sind überbewertet, mehr als zwei braucht man nicht -
 Sphere-Tracing für jedermann"

I.) Motiviation
 - Spaß/Neugier
 - Begrenzung von Abhängigkeiten (Lizenzkosten, binary size)
 - Kenntnisse von unterschiedlichen Rendering-Algorithmen
 - erster Teil einer Vortragsreihe über Rendermethoden für's C++-Treffen
 - die Ausrede für SIMD & Parallelisierung (Threadripper/EPYC, Xeon Phi)

Diagramme:
 - pixel-grid "color a pixel"
 - raymarching in 2d ("instant" hit)
 - view-ray creation/camera/viewpoint
 - raymarching in 3d (marching steps, 2 break-conditions)
 - (deferred vs forward rendering)
 - lambert shading
 - blinn-phong
 - (pbr)
 - shadows / reflection
 - terrain texture-lookup
 - gamma-correction / tone-mapping / vignette
 - normal calculation
 - boolean ops
 - smin, fOpColumn
 - domain repetition (and folding) vs for-loops
 - ball and plane

II.) Grundlagen
 - Ursprung
 - Einordnung im Bereich Rendermethoden (Ray/tracing/marching/casting, Scan)
 - typische Anwendungen (Font-Rendering, Demoszene, kompakte Geometrie)
 - Beispiele aus der Industrie (PS3-Spiel, font-rendering/Qt, Valve)
 - Pro/Contra
   * pro: unendliche Geometrie
   * pro: prozedural -> sehr kompakt
   * pro: mathematisch perfekt, keine Approximation
   * pro: kinderleichte (weiche) Schatten
   * pro: 2D-Variante eignet sich z.B. für auflösungs-unabhäng. Plots
   * contra: umständlicher zu "modellieren" -> keine Tools à la blender
   * contra: kein spezielle Hardware für Beschleunigung
   * contra: Objektumrisse können Darstellungsartefakte verursachen
   * contra: Unstetigkeiten im distance-field führen zu Artefakten

II.) Grundlagen
 - grundlegender Algorithmus
 - Geometrie: Ebene, Kugel, Quarder, Zylinder...
 - wie man an die ganzen SDFs kommt: von Kugel, Ebene, Zylinder, Quarder...
 - Transformation: "manipuliere den Raum, nicht das Objekt"
   * Wiederholung "unendliche Geometrien"
   * Verbiegen
 - Beleuchtung: Normalen, Schatten
 - Oberflächen: Shading-Modelle Gouraud, Lambert, Blinn/Phong, Cook-Torrance/PBR
 - Variation: (Perlin)-Noise für Geometrie und Texturen
 - Boolsche Operationen
   * CSG-like, min/max/not
   * "smooth min/max"
 - sonstige Tricks
   * "iteration glow"
   * "Nebel"
   * Ambient Occlusion
   * volumetrische Medien

III.) Implementation
 - ausnahmsweise kein OpenGL, rein C++-11/14/17 -> nur CPU
 - SDL für Andindung an Fenster-System, damit man was sieht
 - DSL "GL fragment shader für die CPU"
 - sehr funktional angelegt, damit es sich leicher parallelisieren läßt

IV.) Resourcen & weiterführende Literatur
 - wie weit kann man diesen Ansatz treiben? -> Beispiele von iq
 - git-repository http://github.com/MacSlow/raymarching-vortrag
 - "Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of 
    Implicit Surfaces" by John C. Hart
    http://mathinfo.univ-reims.fr/IMG/pdf/hart94sphere.pdf
 - iq/ShaderToy
 - Kleinert et alhttp://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf

V.) Fragen
